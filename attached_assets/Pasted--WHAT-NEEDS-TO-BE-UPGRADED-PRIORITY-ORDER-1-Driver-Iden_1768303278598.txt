âœ… WHAT NEEDS TO BE UPGRADED (PRIORITY ORDER)
1ï¸âƒ£ Driver Identity Resolution (MOST IMPORTANT)

Problem:
Coordinates alone are not enough.

Upgrade to:
ğŸ§  Probabilistic Identity Matching

Strategy to apply

For every new driver point:

Compare against active tracks

Compute a match score, not equality

Use these signals (ALL combined):
Signal	Why
Distance	proximity
Bearing similarity	motion direction
Speed delta	realistic motion
ETA similarity	Uber hint
Time gap	decay logic
Core logic (pseudo)
score =
  w1 * distance_score +
  w2 * bearing_score +
  w3 * speed_score +
  w4 * eta_score -
  w5 * time_penalty


â¡ Match to the highest score above threshold
â¡ Else create new track

This alone fixes ~70% of false counts

2ï¸âƒ£ Motion Prediction (KALMAN-LIKE BUT SIMPLE)

Problem:
Drivers move / stop / teleport due to refresh noise

Upgrade to:
ğŸ“ Short-term trajectory prediction

Strategy

For each driver track, maintain:

last_position

velocity vector

last_update_time

Predict where driver should be at next poll.

predicted_lat = last_lat + v_lat * delta_t
predicted_lng = last_lng + v_lng * delta_t


Then:

Match incoming points against predicted position, not last position

This allows:

fast drivers

stopped drivers

GPS jitter

3ï¸âƒ£ Track Lifecycle Management (CRITICAL)

Problem:
Drivers disappear & reappear â†’ double counting

Upgrade to:
â³ Track states

States to implement
ACTIVE â†’ MISSING â†’ DEAD

Rules

ACTIVE: seen in last N seconds

MISSING: not seen but within TTL

DEAD: expired, archived

Do NOT delete immediately.

This prevents:

short disappearances creating new drivers

spikes in driver count

4ï¸âƒ£ Spatial Indexing (PERFORMANCE + ACCURACY)

Problem:
Comparing every driver to every track is noisy

Upgrade to:
ğŸ—ºï¸ Grid or GeoHash bucketing

Strategy

Divide map into small cells (~100â€“200m)

Only compare drivers within same or adjacent cells

Benefits:

Faster

Less false matches

Scales 24/7

5ï¸âƒ£ Density & Flow Intelligence (WHAT YOU WANT)

You donâ€™t actually need perfect driver paths.

You need:

â€œWhere drivers accumulate & where they leaveâ€

Upgrade to:

ğŸ“Š Heat + Flow model

Track:

driver count per cell

inflow / outflow rate

dwell time

Detect:

dropoff hotspots

pickup scarcity

surge precursors

6ï¸âƒ£ Temporal Learning (YOUR â€œINTELLIGENCEâ€)

Problem:
Raw data â‰  intelligence

Upgrade to:
ğŸ§  Time-bucketed historical patterns

Store per area:

hour of day

day of week

driver delta

dwell duration

Then compute:

expected_driver_count
expected_outflow
anomaly_score


This lets you say:

â€œFremantle usually loses drivers at 9:40pm â€” move thereâ€

7ï¸âƒ£ Confidence-Weighted Decisions (VERY IMPORTANT)

Never make binary claims.

Instead compute:

confidence = data_volume Ã— consistency Ã— recency


Only suggest movement if:

confidence > threshold

This avoids chasing noise.

8ï¸âƒ£ API CALL STRATEGY (SUBTLE BUT HUGE)

Problem:
Single-point polling biases results

Upgrade to:
ğŸ“ Multi-anchor polling

Strategy

Poll:

Fremantle

Perth CBD

Midpoints between

Then merge tracks.

This reveals directional flow, not just presence.

ğŸš¨ WHAT YOU SHOULD NOT TRY TO DO

âŒ Reconstruct exact Uber trips
âŒ Identify drivers personally
âŒ Track individual driver for hours reliably
âŒ Fight Uberâ€™s obfuscation directly

Uber wins those battles.

You win by statistical dominance.

ğŸ§  WHAT YOUR SYSTEM REALLY BECOMES

Not:

â€œTracking driversâ€

But:

â€œReal-time supply flow intelligence engineâ€

This is how hedge funds, traffic control, and ride-share optimizers work.